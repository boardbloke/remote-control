import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.locks.ReentrantLock

buildscript {
    repositories {
        jcenter()
    }

    dependencies {
        classpath "org.gradle.api.plugins:gradle-clover-plugin:0.6.1"
        classpath "org.jfrog.buildinfo:build-info-extractor-gradle:2.2.3"
        classpath "org.gebish:markdown2book:1.0"
    }
}

def jvmEncoding = java.nio.charset.Charset.defaultCharset().name()
if (jvmEncoding != "UTF-8") {
    throw new IllegalStateException("Build environment must be UTF-8 (it is: $jvmEncoding) - add '-Dfile.encoding=UTF-8' to the GRADLE_OPTS environment variable ")
}

allprojects {
    version = '0.8-SNAPSHOT'
    group = 'io.remotecontrol'

    ext {
        isSnapshot = version.endsWith("SNAPSHOT")
        groovyVersion = "3.0.11"
        spockVersion = "2.1-groovy-3.0"

        spockDependency = "org.spockframework:spock-core:$spockVersion"
        groovyDependency = "org.codehaus.groovy:groovy-all:$groovyVersion"
    }

    repositories {
        jcenter()
    }

    apply plugin: "idea"
}

//apply plugin: 'artifactory'
//
//artifactory {
//    contextUrl = 'http://oss.jfrog.org'
//}
//
//artifactoryPublish { task ->
//    skip true
//    rootProject.artifactory {
//        publish {
//            repository {
//                repoKey = isSnapshot ? 'oss-snapshot-local' : 'oss-release-local'
//                gradle.taskGraph.whenReady { taskGraph ->
//                    if (taskGraph.hasTask(task)) {
//                        username = ratpackBintrayUser
//                        password = ratpackBintrayApiKey
//                    }
//                }
//            }
//        }
//    }
//}

apply from: "$rootDir/gradle/idea.gradle"

def groovyModules = [
        ":module:remote-core", ":module:remote-transport-local", ":module:remote-transport-http"
]

def publishedModules = [
        ":module:remote-core", ":module:remote-transport-local", ":module:remote-transport-http"
]

def publishedGroovyModules = groovyModules.findAll { it in publishedModules }

subprojects {
    if (project.path in groovyModules) {
        apply plugin: "groovy"
        apply plugin: "codenarc"

        codenarc {
            configFile = rootProject.file("config/codenarc/codenarc.xml")
        }

        dependencies {
            implementation groovyDependency
            testImplementation spockDependency
        }

        sourceCompatibility = 1.8
        targetCompatibility = 1.8

        tasks.withType(GroovyCompile) {
            configure(groovyOptions) {
                forkOptions.jvmArgs = ['-Xmx1024m']
            }
        }

        tasks.withType(Test) {
            useJUnitPlatform()
        }
    }

    if (project.path in publishedModules) {
        apply plugin: 'maven-publish'
//        apply plugin: 'artifactory'
        apply from: "$rootDir/gradle/pom.gradle"
        apply plugin: 'signing'

        task sourcesJar(type: Jar) {
            classifier = 'sources'
            from sourceSets.main.allSource
        }

        task javadocJar(type: Jar) {
            classifier = 'javadoc'
            from javadoc
        }

        signing {
            sign configurations.archives
            required { !isSnapshot && gradle.taskGraph.hasTask(artifactoryPublish) }
        }

        artifacts {
            archives javadocJar
            archives sourcesJar
        }


        modifyPom { pom ->
            pom.dependencies.removeAll(pom.dependencies.findAll { it.scope == "test" })

            pom.project {
                name project.name
                description project.description
                if (description == null) {
                    throw new InvalidUserDataException("Project '$project' has no description")
                }
                url "http://remotecontrol.io"
                inceptionYear "2010"
                licenses {
                    license {
                        name 'The Apache Software License, Version 2.0'
                        url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
                        distribution 'repo'
                    }
                }
                scm {
                    url "https://github.com/alkemist/remote-control"
                }
                developers {
                    developer {
                        id "ldaley"
                        name "Luke Daley"
                        roles {
                            role "Lead"
                            role "Founder"
                        }
                    }
                }
            }
        }
    }
}


project(':module:remote-core') {
    description "Provides the core of the remote library"
    dependencies {
        testImplementation project(":module:remote-transport-local"), project(":module:remote-using-lib")
    }
}

project(':module:remote-transport-http') {
    description "Support for sending and receiving remote commands over HTTP (including a servlet implementation)"
    dependencies {
        implementation project(":module:remote-core")
        implementation "javax.servlet:servlet-api:2.4"
        testImplementation "org.eclipse.jetty:jetty-server:11.0.11"
    }
}

project(':module:remote-transport-local') {
    description "Provides an in process bridge for sending/receiving commands"
    dependencies {
        implementation project(":module:remote-core")
    }
}

project(':module:remote-using-lib') {
    apply plugin: "groovy"

    dependencies {
        implementation groovyDependency
        implementation project(":module:remote-core")
    }
}

project(":doc:manual") {
    ext {
        src = file("src")
        output = file("build/manual")
    }

    tasks.register("compile") {
        doLast {
            new markdown2book.Generator(src, output, "UTF-8").generate()
        }
    }

    tasks.register("copyGroovyDoc") {
        dependsOn publishedGroovyModules.collect { project(it) }*.groovydoc
        doLast {
            def groovyApi = new File(output, "groovy-api")
            if (!groovyApi.exists()) {
                assert groovyApi.mkdirs()
            }

            publishedGroovyModules.collect { module ->
                def baseName = module[module.lastIndexOf(":") + 1..module.size() - 1]
                copy {
                    from project(module).groovydoc.destinationDir
                    into new File(groovyApi, baseName)
                }
            }
        }
    }

    tasks.register('assemble') {
        dependsOn tasks.compile, tasks.copyGroovyDoc
    }
}

project(":doc:site") {
    ext {
        src = file("src")
        output = file("build/site")
        manualDir = file("$output/manual")
        thisManual = file("$manualDir/$project.version")
    }

    tasks.register('clean') {
        doLast {
            if (output.exists()) {
                assert output.deleteDir()
            }
        }
    }

    task includeManual(dependsOn: project(":doc:manual").assemble, type: Sync) {
        from project(":doc:manual").output
        into project.thisManual

        doLast {
            ant.symlink link: "${manualDir.path}/latest", resource: thisManual.path, overwrite: true
        }
    }

    task copySrc(type: Copy) {
        from src
        into output
    }

    task compile(dependsOn: [copySrc, includeManual]) {}
}

// Maven POM generation is not thread safe, so serialize all the Upload tasks we can use `--parallel`.
def lock = new ReentrantLock()
def available = lock.newCondition()
def busy = new AtomicBoolean()
allprojects {
    tasks.withType(Upload) { uploadTask ->
        doFirst {
            lock.lock()
            while (busy.get()) {
                available.await()
            }
            busy.set(true)
        }
    }
}
gradle.taskGraph.afterTask {
    if (it instanceof Upload && lock.heldByCurrentThread) {
        busy.set(false)
        available.signal()
        lock.unlock()
    }
}

